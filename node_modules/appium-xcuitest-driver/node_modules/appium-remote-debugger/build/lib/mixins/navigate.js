"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_PAGE_READINESS_TIMEOUT_MS = void 0;
exports.frameDetached = frameDetached;
exports.cancelPageLoad = cancelPageLoad;
exports.isPageLoadingCompleted = isPageLoadingCompleted;
exports.waitForDom = waitForDom;
exports.checkPageIsReady = checkPageIsReady;
exports.navToUrl = navToUrl;
const utils_1 = require("../utils");
const events_1 = require("./events");
const support_1 = require("@appium/support");
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importStar(require("bluebird"));
const property_accessors_1 = require("./property-accessors");
exports.DEFAULT_PAGE_READINESS_TIMEOUT_MS = 20 * 1000;
const PAGE_READINESS_CHECK_INTERVAL_MS = 50;
/**
 * pageLoadStrategy in WebDriver definitions.
 */
const PAGE_LOAD_STRATEGY = Object.freeze({
    EAGER: 'eager',
    NONE: 'none',
    NORMAL: 'normal'
});
/**
 * @this {RemoteDebugger}
 * @returns {void}
 */
function frameDetached() {
    this.emit(events_1.events.EVENT_FRAMES_DETACHED);
}
/**
 * @this {RemoteDebugger}
 * @returns {void}
 */
function cancelPageLoad() {
    this.log.debug('Unregistering from page readiness notifications');
    (0, property_accessors_1.setPageLoading)(this, false);
    (0, property_accessors_1.getPageLoadDelay)(this)?.cancel();
}
/**
 * Return if current readState can be handles as page load completes
 * for the given page load strategy.
 *
 * @this {RemoteDebugger}
 * @param {string} readyState
 * @returns {boolean}
 */
function isPageLoadingCompleted(readyState) {
    const pageLoadStrategy = lodash_1.default.toLower((0, property_accessors_1.getPageLoadStartegy)(this));
    switch (pageLoadStrategy) {
        case PAGE_LOAD_STRATEGY.EAGER:
            // This could include 'interactive' or 'complete'
            return readyState !== 'loading';
        case PAGE_LOAD_STRATEGY.NONE:
            return true;
        case PAGE_LOAD_STRATEGY.NORMAL:
        default:
            return readyState === 'complete';
    }
}
/**
 * @this {RemoteDebugger}
 * @param {timing.Timer?} [startPageLoadTimer]
 * @returns {Promise<void>}
 */
async function waitForDom(startPageLoadTimer) {
    const readinessTimeoutMs = this.pageLoadMs;
    this.log.debug(`Waiting up to ${readinessTimeoutMs}ms for the page to be ready`);
    const timer = startPageLoadTimer ?? new support_1.timing.Timer().start();
    let isPageLoading = true;
    (0, property_accessors_1.setPageLoading)(this, true);
    (0, property_accessors_1.setPageLoadDelay)(this, support_1.util.cancellableDelay(readinessTimeoutMs));
    /** @type {B<void>} */
    const pageReadinessPromise = bluebird_1.default.resolve((async () => {
        let retry = 0;
        while (isPageLoading) {
            // if we are ready, or we've spend too much time on this
            const elapsedMs = timer.getDuration().asMilliSeconds;
            // exponential retry
            const intervalMs = Math.min(PAGE_READINESS_CHECK_INTERVAL_MS * Math.pow(2, retry), readinessTimeoutMs - elapsedMs);
            await bluebird_1.default.delay(intervalMs);
            // we can get this called in the middle of trying to find a new app
            if (!(0, property_accessors_1.getAppIdKey)(this)) {
                this.log.debug('Not connected to an application. Ignoring page readiess check');
                return;
            }
            if (!isPageLoading) {
                return;
            }
            const maxWaitMs = (readinessTimeoutMs - elapsedMs) * 0.95;
            if (await this.checkPageIsReady(maxWaitMs)) {
                if (isPageLoading) {
                    this.log.debug(`Page is ready in ${elapsedMs}ms`);
                    isPageLoading = false;
                }
                return;
            }
            if (elapsedMs > readinessTimeoutMs) {
                this.log.info(`Timed out after ${readinessTimeoutMs}ms of waiting for the page readiness. Continuing anyway`);
                isPageLoading = false;
                return;
            }
            retry++;
        }
    })());
    /** @type {B<void>} */
    const cancellationPromise = bluebird_1.default.resolve((async () => {
        try {
            await (0, property_accessors_1.getPageLoadDelay)(this);
        }
        catch { }
    })());
    try {
        await bluebird_1.default.any([cancellationPromise, pageReadinessPromise]);
    }
    finally {
        isPageLoading = false;
        (0, property_accessors_1.setPageLoading)(this, false);
        (0, property_accessors_1.setPageLoadDelay)(this, bluebird_1.default.resolve());
    }
}
/**
 * @this {RemoteDebugger}
 * @param {number} [timeoutMs]
 * @returns {Promise<boolean>}
 */
async function checkPageIsReady(timeoutMs) {
    const readyCmd = 'document.readyState;';
    const actualTimeoutMs = timeoutMs ?? (0, property_accessors_1.getPageReadyTimeout)(this);
    try {
        const readyState = await bluebird_1.default.resolve(this.execute(readyCmd))
            .timeout(actualTimeoutMs);
        this.log.debug(JSON.stringify({
            readyState,
            pageLoadStrategy: (0, property_accessors_1.getPageLoadStartegy)(this) ?? PAGE_LOAD_STRATEGY.NORMAL,
        }));
        return this.isPageLoadingCompleted(readyState);
    }
    catch (err) {
        if (err instanceof bluebird_1.TimeoutError) {
            this.log.debug(`Page readiness check timed out after ${actualTimeoutMs}ms`);
        }
        else {
            this.log.warn(`Page readiness check has failed. Original error: ${err.message}`);
        }
        return false;
    }
}
/**
 * @this {RemoteDebugger}
 * @param {string} url
 * @returns {Promise<void>}
 */
async function navToUrl(url) {
    const { appIdKey, pageIdKey } = (0, utils_1.checkParams)({
        appIdKey: (0, property_accessors_1.getAppIdKey)(this),
        pageIdKey: (0, property_accessors_1.getPageIdKey)(this),
    });
    const rpcClient = this.requireRpcClient();
    try {
        new URL(url);
    }
    catch {
        throw new TypeError(`'${url}' is not a valid URL`);
    }
    this.log.debug(`Navigating to new URL: '${url}'`);
    (0, property_accessors_1.setNavigatingToPage)(this, true);
    await rpcClient.waitForPage(
    /** @type {import('../types').AppIdKey} */ (appIdKey), 
    /** @type {import('../types').PageIdKey} */ (pageIdKey));
    const readinessTimeoutMs = this.pageLoadMs;
    /** @type {(() => void)|undefined} */
    let onPageLoaded;
    /** @type {NodeJS.Timeout|undefined|null} */
    let onPageLoadedTimeout;
    (0, property_accessors_1.setPageLoadDelay)(this, support_1.util.cancellableDelay(readinessTimeoutMs));
    (0, property_accessors_1.setPageLoading)(this, true);
    let isPageLoading = true;
    // /** @type {Promise<void>|null} */
    const start = new support_1.timing.Timer().start();
    /** @type {B<void>} */
    const pageReadinessPromise = new bluebird_1.default((resolve) => {
        onPageLoadedTimeout = setTimeout(() => {
            if (isPageLoading) {
                isPageLoading = false;
                this.log.info(`Timed out after ${start.getDuration().asMilliSeconds.toFixed(0)}ms of waiting ` +
                    `for the ${url} page readiness. Continuing anyway`);
            }
            return resolve();
        }, readinessTimeoutMs);
        onPageLoaded = () => {
            if (isPageLoading) {
                isPageLoading = false;
                this.log.debug(`The page ${url} is ready in ${start.getDuration().asMilliSeconds.toFixed(0)}ms`);
            }
            if (onPageLoadedTimeout) {
                clearTimeout(onPageLoadedTimeout);
                onPageLoadedTimeout = null;
            }
            return resolve();
        };
        // https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-loadEventFired
        rpcClient.once('Page.loadEventFired', onPageLoaded);
        rpcClient.send('Page.navigate', {
            url,
            appIdKey,
            pageIdKey,
        });
    });
    /** @type {B<void>} */
    const cancellationPromise = bluebird_1.default.resolve((async () => {
        try {
            await (0, property_accessors_1.getPageLoadDelay)(this);
        }
        catch { }
    })());
    try {
        await bluebird_1.default.any([cancellationPromise, pageReadinessPromise]);
    }
    finally {
        (0, property_accessors_1.setPageLoading)(this, false);
        isPageLoading = false;
        (0, property_accessors_1.setNavigatingToPage)(this, false);
        (0, property_accessors_1.setPageLoadDelay)(this, bluebird_1.default.resolve());
        if (onPageLoadedTimeout && pageReadinessPromise.isFulfilled()) {
            clearTimeout(onPageLoadedTimeout);
            onPageLoadedTimeout = null;
        }
        if (onPageLoaded) {
            rpcClient.off('Page.loadEventFired', onPageLoaded);
        }
    }
}
/**
 * @typedef {import('../remote-debugger').RemoteDebugger} RemoteDebugger
 */
//# sourceMappingURL=navigate.js.map