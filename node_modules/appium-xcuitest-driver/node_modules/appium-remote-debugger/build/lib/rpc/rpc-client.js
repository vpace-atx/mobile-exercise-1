"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcClient = exports.EMPTY_PAGE_DICTIONARY_ERROR = exports.NEW_APP_CONNECTED_ERROR = void 0;
const remote_messages_1 = require("./remote-messages");
const asyncbox_1 = require("asyncbox");
const logger_1 = __importDefault(require("../logger"));
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const rpc_message_handler_1 = __importDefault(require("./rpc-message-handler"));
const support_1 = require("@appium/support");
const node_events_1 = require("node:events");
const async_lock_1 = __importDefault(require("async-lock"));
const utils_1 = require("../utils");
const DATA_LOG_LENGTH = { length: 200 };
const MIN_WAIT_FOR_TARGET_TIMEOUT_MS = 30000;
// Sometimes page initialization can take a long time, especially in slow CI environments,
// although we still should not allow it to take forever
const PAGE_INIT_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes
const WAIT_FOR_TARGET_INTERVAL_MS = 100;
const NO_TARGET_SUPPORTED_ERROR = `'target' domain was not found`;
const MISSING_TARGET_ERROR_PATTERN = /Missing target/i;
const NO_TARGET_PRESENT_YET_ERRORS = [
    `domain was not found`,
    `some arguments of method`,
    `missing target`,
];
exports.NEW_APP_CONNECTED_ERROR = 'New application has connected';
exports.EMPTY_PAGE_DICTIONARY_ERROR = 'Empty page dictionary received';
const ON_PAGE_INITIALIZED_EVENT = 'onPageInitialized';
class RpcClient {
    /** @type {RpcMessageHandler|undefined} */
    messageHandler;
    /** @type {RemoteMessages|undefined} */
    remoteMessages;
    /** @type {boolean} */
    connected;
    /** @type {boolean} */
    isSafari;
    /** @type {string} */
    connId;
    /** @type {string} */
    senderId;
    /** @type {number} */
    msgId;
    /** @type {string|undefined} */
    udid;
    /** @type {boolean|undefined} */
    logAllCommunication;
    /** @type {boolean|undefined} */
    logAllCommunicationHexDump;
    /** @type {number|undefined} */
    socketChunkSize;
    /** @type {number|undefined} */
    webInspectorMaxFrameLength;
    /** @type {boolean|undefined} */
    fullPageInitialization;
    /** @type {string|undefined} */
    bundleId;
    /** @type {number | undefined} */
    pageLoadTimeoutMs;
    /** @type {string} */
    platformVersion;
    /** @type {string[]} */
    _contexts;
    /** @type {AppToTargetsMap} */
    _targets;
    /** @type {EventEmitter} */
    _targetSubscriptions;
    /** @type {PendingTargetNotification | undefined} */
    _pendingTargetNotification;
    /**
     *
     * @param {RpcClientOptions} [opts={}]
     */
    constructor(opts = {}) {
        const { bundleId, platformVersion = '', isSafari = true, logAllCommunication = false, logAllCommunicationHexDump = false, webInspectorMaxFrameLength, socketChunkSize, fullPageInitialization = false, udid, pageLoadTimeoutMs, } = opts;
        this.isSafari = isSafari;
        this.isConnected = false;
        this.connId = support_1.util.uuidV4();
        this.senderId = support_1.util.uuidV4();
        this.msgId = 0;
        this.udid = udid;
        this.logAllCommunication = logAllCommunication;
        this.logAllCommunicationHexDump = logAllCommunicationHexDump;
        this.socketChunkSize = socketChunkSize;
        this.webInspectorMaxFrameLength = webInspectorMaxFrameLength;
        this.pageLoadTimeoutMs = pageLoadTimeoutMs;
        this.fullPageInitialization = fullPageInitialization;
        this.bundleId = bundleId;
        this.platformVersion = platformVersion;
        this._contexts = [];
        this._targets = {};
        this._targetSubscriptions = new node_events_1.EventEmitter();
        this._provisionedPages = new Set();
        this._pageSelectionLock = new async_lock_1.default();
        this._pageSelectionMonitor = new node_events_1.EventEmitter();
        this.remoteMessages = new remote_messages_1.RemoteMessages();
        this.messageHandler = new rpc_message_handler_1.default();
        // add handlers for internal events
        this.messageHandler.on('Target.targetCreated', this.addTarget.bind(this));
        this.messageHandler.on('Target.didCommitProvisionalTarget', this.updateTarget.bind(this));
        this.messageHandler.on('Target.targetDestroyed', this.removeTarget.bind(this));
        this.messageHandler.on('Runtime.executionContextCreated', this.onExecutionContextCreated.bind(this));
        this.messageHandler.on('Heap.garbageCollected', this.onGarbageCollected.bind(this));
    }
    /**
     * @returns {string[]}
     */
    get contexts() {
        return this._contexts;
    }
    /**
     * @returns {AppToTargetsMap}
     */
    get targets() {
        return this._targets;
    }
    /**
     * @returns {boolean}
     */
    get isConnected() {
        return this.connected;
    }
    /**
     * @param {boolean} connected
     */
    set isConnected(connected) {
        this.connected = !!connected;
    }
    /**
     * @returns {EventEmitter}
     */
    get targetSubscriptions() {
        return this._targetSubscriptions;
    }
    /**
     *
     * @param {string} event
     * @param {Function} listener
     * @returns {this}
     */
    on(event, listener) {
        // @ts-ignore messageHandler must be defined here
        this.messageHandler.on(event, listener);
        return this;
    }
    /**
     *
     * @param {string} event
     * @param {Function} listener
     * @returns {this}
     */
    once(event, listener) {
        // @ts-ignore messageHandler must be defined here
        this.messageHandler.once(event, listener);
        return this;
    }
    /**
     * @param {string} event
     * @param {Function} listener
     * @returns {this}
     */
    off(event, listener) {
        // @ts-ignore messageHandler must be defined here
        this.messageHandler.off(event, listener);
        return this;
    }
    /**
     *
     * @param {import('../types').AppIdKey} appIdKey
     * @param {import('../types').PageIdKey} pageIdKey
     * @returns {Promise<import('../types').TargetId | undefined>}
     */
    async waitForTarget(appIdKey, pageIdKey) {
        let target = this.getTarget(appIdKey, pageIdKey);
        if (target) {
            logger_1.default.debug(`The target '${target}' for app '${appIdKey}' and page '${pageIdKey}' already exists, no need to wait`);
            return target;
        }
        // otherwise waiting is necessary to see what the target is
        const waitMs = Math.max(MIN_WAIT_FOR_TARGET_TIMEOUT_MS, this.pageLoadTimeoutMs || 0);
        logger_1.default.debug(`Waiting up to ${waitMs}ms for a target to be created for ` +
            `app '${appIdKey}' and page '${pageIdKey}'`);
        try {
            await (0, asyncbox_1.waitForCondition)(() => {
                target = this.getTarget(appIdKey, pageIdKey);
                return !lodash_1.default.isEmpty(target);
            }, {
                waitMs,
                intervalMs: WAIT_FOR_TARGET_INTERVAL_MS,
            });
            return target;
        }
        catch (err) {
            if (!err.message.includes('Condition unmet')) {
                throw err;
            }
            throw new Error(`No targets could be matched for the app '${appIdKey}' and page '${pageIdKey}' after ${waitMs}ms`);
        }
    }
    /**
     *
     * @param {string} command
     * @param {import('../types').RemoteCommandOpts} opts
     * @param {boolean} [waitForResponse=true]
     * @returns {Promise<any>}
     */
    async send(command, opts, waitForResponse = true) {
        const timer = new support_1.timing.Timer().start();
        try {
            return await this.sendToDevice(command, opts, waitForResponse);
        }
        catch (err) {
            const { appIdKey, pageIdKey } = opts;
            const messageLc = (err.message || '').toLowerCase();
            if (messageLc.includes(NO_TARGET_SUPPORTED_ERROR)) {
                return await this.sendToDevice(command, opts, waitForResponse);
            }
            else if (appIdKey && NO_TARGET_PRESENT_YET_ERRORS.some((error) => messageLc.includes(error))) {
                await this.waitForTarget(appIdKey, /** @type {import('../types').PageIdKey} */ (pageIdKey));
                return await this.sendToDevice(command, opts, waitForResponse);
            }
            throw err;
        }
        finally {
            logger_1.default.debug(`Sending to Web Inspector took ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
        }
    }
    /**
     *
     * @template {boolean} TWaitForResponse
     * @param {string} command
     * @param {import('../types').RemoteCommandOpts} opts
     * @param {TWaitForResponse} [waitForResponse=true]
     * @returns {Promise<TWaitForResponse extends true ? import('../types').RemoteCommandOpts : any>}
     */
    // @ts-ignore Compiler issue
    async sendToDevice(command, opts, waitForResponse = true) {
        return await new bluebird_1.default(async (resolve, reject) => {
            // promise to be resolved whenever remote debugger
            // replies to our request
            // keep track of the messages coming and going using a simple sequential id
            const msgId = this.msgId++;
            // for target-base communication, everything is wrapped up
            const wrapperMsgId = this.msgId++;
            // acknowledge wrapper message
            // @ts-ignore messageHandler must be defined
            this.messageHandler.on(wrapperMsgId.toString(), function (err) {
                if (err) {
                    reject(err);
                }
            });
            const appIdKey = opts.appIdKey;
            const pageIdKey = opts.pageIdKey;
            const targetId = opts.targetId ?? this.getTarget(appIdKey, pageIdKey);
            // retrieve the correct command to send
            /** @type {import('../types').RemoteCommandOpts} */
            const fullOpts = lodash_1.default.defaults({
                connId: this.connId,
                senderId: this.senderId,
                targetId,
                id: msgId,
            }, opts);
            /** @type {import('../types').RawRemoteCommand} */
            let cmd;
            try {
                // @ts-ignore remoteMessages must be defined
                cmd = this.remoteMessages.getRemoteCommand(command, fullOpts);
            }
            catch (err) {
                logger_1.default.error(err);
                return reject(err);
            }
            /** @type {import('../types').RemoteCommand} */
            const finalCommand = {
                __argument: lodash_1.default.omit(cmd.__argument, ['WIRSocketDataKey']),
                __selector: cmd.__selector,
            };
            const hasSocketData = lodash_1.default.isPlainObject(cmd.__argument?.WIRSocketDataKey);
            if (hasSocketData) {
                // make sure the message being sent has all the information that is needed
                // @ts-ignore We have asserted it's a plain object above
                if (lodash_1.default.isNil(cmd.__argument.WIRSocketDataKey.id)) {
                    // @ts-ignore We have already asserted it's a plain object above
                    cmd.__argument.WIRSocketDataKey.id = wrapperMsgId;
                }
                finalCommand.__argument.WIRSocketDataKey = Buffer.from(JSON.stringify(cmd.__argument.WIRSocketDataKey));
            }
            let messageHandled = true;
            if (!waitForResponse) {
                // the promise will be resolved as soon as the socket has been sent
                messageHandled = false;
                // do not log receipts
                // @ts-ignore messageHandler must be defined
                this.messageHandler.once(msgId.toString(), (err) => {
                    if (err) {
                        // we are not waiting for this, and if it errors it is most likely
                        // a protocol change. Log and check during testing
                        logger_1.default.error(`Received error from send that is not being waited for (id: ${msgId}): ` +
                            lodash_1.default.truncate(JSON.stringify(err), DATA_LOG_LENGTH));
                        // reject, though it is very rare that this will be triggered, since
                        // the promise is resolved directlty after send. On the off chance,
                        // though, it will alert of a protocol change.
                        reject(err);
                    }
                });
                // @ts-ignore messageHandler must be defined
            }
            else if (this.messageHandler.listeners(cmd.__selector).length) {
                // @ts-ignore messageHandler must be defined
                this.messageHandler.prependOnceListener(cmd.__selector, (err, ...args) => {
                    if (err) {
                        return reject(err);
                    }
                    logger_1.default.debug(`Received response from send (id: ${msgId}): '${lodash_1.default.truncate(JSON.stringify(args), DATA_LOG_LENGTH)}'`);
                    // @ts-ignore This is ok
                    resolve(args);
                });
            }
            else if (hasSocketData) {
                // @ts-ignore messageHandler must be defined
                this.messageHandler.once(msgId.toString(), (err, value) => {
                    if (err) {
                        return reject(new Error(`Remote debugger error with code '${err.code}': ${err.message}`));
                    }
                    logger_1.default.debug(`Received data response from send (id: ${msgId}): '${lodash_1.default.truncate(JSON.stringify(value), DATA_LOG_LENGTH)}'`);
                    resolve(value);
                });
            }
            else {
                // nothing else is handling things, so just resolve when the message is sent
                messageHandled = false;
            }
            const msg = `Sending '${cmd.__selector}' message` +
                (appIdKey ? ` to app '${appIdKey}'` : '') +
                (pageIdKey ? `, page '${pageIdKey}'` : '') +
                (targetId ? `, target '${targetId}'` : '') +
                ` (id: ${msgId}): '${command}'`;
            logger_1.default.debug(msg);
            try {
                await this.sendMessage(finalCommand);
                if (!messageHandled) {
                    // There are no handlers waiting for a response before resolving,
                    // and no errors sending the message over the socket, so resolve
                    // @ts-ignore This is ok
                    resolve(fullOpts);
                }
            }
            catch (err) {
                return reject(err);
            }
        });
    }
    async connect() {
        throw new Error(`Sub-classes need to implement a 'connect' function`);
    }
    async disconnect() {
        this.messageHandler?.removeAllListeners();
    }
    /**
     * @param {import('../types').RemoteCommand} command
     * @returns {Promise<void>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async sendMessage(command) {
        throw new Error(`Sub-classes need to implement a 'sendMessage' function`);
    }
    /**
     * @param {any} data
     * @returns {Promise<void>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async receive(data) {
        throw new Error(`Sub-classes need to implement a 'receive' function`);
    }
    /**
     *
     * @param {Error | undefined} err
     * @param {import('../types').AppIdKey} app
     * @param {import('../types').TargetInfo} targetInfo
     * @returns {Promise<void>}
     */
    async addTarget(err, app, targetInfo) {
        if (lodash_1.default.isNil(targetInfo?.targetId)) {
            logger_1.default.info(`Received 'Target.targetCreated' event for app '${app}' with no target. Skipping`);
            return;
        }
        if (!this._pendingTargetNotification) {
            logger_1.default.info(`Received 'Target.targetCreated' event for app '${app}' with no pending request: ${JSON.stringify(targetInfo)}`);
            return;
        }
        const [appIdKey, pageIdKey, pageReadinessDetector] = this._pendingTargetNotification;
        if (appIdKey !== app) {
            logger_1.default.info(`Received 'Target.targetCreated' event for app '${app}' with no pending request: ${JSON.stringify(targetInfo)}`);
            return;
        }
        const pageInitTimeoutMs = Math.max(this.pageLoadTimeoutMs ?? 0, PAGE_INIT_TIMEOUT_MS);
        if (!lodash_1.default.isPlainObject(this.targets[appIdKey])) {
            this.targets[appIdKey] = {
                lock: new async_lock_1.default({ maxOccupationTime: pageInitTimeoutMs }),
            };
        }
        const timer = new support_1.timing.Timer().start();
        const adjustPageReadinessDetector = () => {
            if (!pageReadinessDetector) {
                return;
            }
            const elapsedMs = timer.getDuration().asMilliSeconds;
            if (elapsedMs >= pageReadinessDetector.timeoutMs) {
                logger_1.default.warn(`Page '${pageIdKey}' took too long to initialize, skipping readiness check`);
                return;
            }
            return {
                timeoutMs: pageReadinessDetector.timeoutMs - elapsedMs,
                readinessDetector: pageReadinessDetector.readinessDetector,
            };
        };
        if (targetInfo.isProvisional) {
            logger_1.default.debug(`Provisional target created for app '${appIdKey}' and page '${pageIdKey}': '${JSON.stringify(targetInfo)}'`);
            this._provisionedPages.add(pageIdKey);
            try {
                await this.targets[appIdKey].lock.acquire(pageIdKey, async () => {
                    let wasInitialized = false;
                    try {
                        wasInitialized = await this._initializePage(appIdKey, pageIdKey, targetInfo.targetId);
                    }
                    finally {
                        if (targetInfo.isPaused) {
                            await this._resumeTarget(appIdKey, pageIdKey, targetInfo.targetId);
                        }
                        else {
                            logger_1.default.debug(`Provisional target ${targetInfo.targetId}@${appIdKey} is not paused, so not resuming`);
                        }
                    }
                    if (wasInitialized) {
                        await this._waitForPageReadiness(appIdKey, pageIdKey, targetInfo.targetId, adjustPageReadinessDetector());
                    }
                });
            }
            catch (e) {
                logger_1.default.warn(`Cannot complete the initialization of the provisional target '${targetInfo.targetId}' ` +
                    `after ${timer.getDuration().asMilliSeconds}ms: ${e.message}`);
            }
            return;
        }
        logger_1.default.debug(`Target created for app '${appIdKey}' and page '${pageIdKey}': ${JSON.stringify(targetInfo)}`);
        if (lodash_1.default.has(this.targets[appIdKey], pageIdKey)) {
            logger_1.default.debug(`There is already a target for this app and page ('${this.targets[appIdKey][pageIdKey]}'). ` +
                `This might cause problems`);
        }
        this.targets[appIdKey][pageIdKey] = targetInfo.targetId;
        try {
            await this.send('Target.setPauseOnStart', {
                pauseOnStart: true,
                appIdKey,
                pageIdKey,
            });
        }
        catch (e) {
            logger_1.default.debug(`Cannot setup pause on start for app '${appIdKey}' and page '${pageIdKey}': ${e.message}`);
        }
        try {
            await this.targets[appIdKey].lock.acquire(pageIdKey, async () => {
                let wasInitialized = false;
                try {
                    if (this._provisionedPages.has(pageIdKey)) {
                        logger_1.default.debug(`Page '${pageIdKey}' has been already provisioned`);
                        this._provisionedPages.delete(pageIdKey);
                    }
                    else {
                        wasInitialized = await this._initializePage(appIdKey, pageIdKey);
                    }
                }
                finally {
                    if (targetInfo.isPaused) {
                        await this._resumeTarget(appIdKey, pageIdKey, targetInfo.targetId);
                    }
                }
                if (wasInitialized) {
                    await this._waitForPageReadiness(appIdKey, pageIdKey, targetInfo.targetId, adjustPageReadinessDetector());
                }
            });
        }
        catch (e) {
            logger_1.default.warn(e.message);
        }
        finally {
            // Target creation is happening after provisioning,
            // which means the above lock would be already released
            // after provisioning is completed.
            this._pageSelectionMonitor.emit(ON_PAGE_INITIALIZED_EVENT, appIdKey, pageIdKey);
        }
    }
    /**
     *
     * @param {Error | undefined} err
     * @param {import('../types').AppIdKey} app
     * @param {import('../types').ProvisionalTargetInfo} targetInfo
     * @returns {Promise<void>}
     */
    async updateTarget(err, app, targetInfo) {
        const { oldTargetId, newTargetId, } = targetInfo;
        logger_1.default.debug(`Target updated for app '${app}'. Old target: '${oldTargetId}', new target: '${newTargetId}'`);
        const appTargetsMap = this.targets[app];
        if (!appTargetsMap) {
            logger_1.default.warn(`No existing target for app '${app}'. Not sure what to do`);
            return;
        }
        // save this, to be used if/when the existing target is destroyed
        appTargetsMap.provisional = {
            oldTargetId,
            newTargetId,
        };
    }
    /**
     *
     * @param {Error | undefined} err
     * @param {import('../types').AppIdKey} app
     * @param {import('../types').TargetInfo} targetInfo
     * @returns {Promise<void>}
     */
    async removeTarget(err, app, targetInfo) {
        if (lodash_1.default.isNil(targetInfo?.targetId)) {
            logger_1.default.debug(`Received 'Target.targetDestroyed' event with no target. Skipping`);
            return;
        }
        logger_1.default.debug(`Target destroyed for app '${app}': ${targetInfo.targetId}`);
        // go through the targets and find the one that has a waiting provisional target
        if (this.targets[app]?.provisional?.oldTargetId === targetInfo.targetId) {
            const { oldTargetId, newTargetId } = this.targets[app].provisional;
            delete this.targets[app].provisional;
            // we do not know the page, so go through and find the existing target
            const appTargetsMap = this.targets[app];
            for (const [page, targetId] of lodash_1.default.toPairs(appTargetsMap)) {
                if (targetId === oldTargetId) {
                    logger_1.default.debug(`Found provisional target for app '${app}'. ` +
                        `Old target: '${oldTargetId}', new target: '${newTargetId}'. Updating`);
                    appTargetsMap[page] = newTargetId;
                    return;
                }
            }
            logger_1.default.warn(`Provisional target for app '${app}' found, but no suitable existing target found. This may cause problems`);
            logger_1.default.warn(`Old target: '${oldTargetId}', new target: '${newTargetId}'. Existing targets: ${JSON.stringify(appTargetsMap)}`);
        }
        // if there is no waiting provisional target, just get rid of the existing one
        const targets = this.targets[app];
        for (const [page, targetId] of lodash_1.default.toPairs(targets)) {
            if (targetId === targetInfo.targetId) {
                delete targets[page];
                return;
            }
        }
        logger_1.default.debug(`Target '${targetInfo.targetId}' deleted for app '${app}', but no such target exists`);
    }
    /**
     * @param {import('../types').AppIdKey} [appIdKey]
     * @param {import('../types').PageIdKey} [pageIdKey]
     * @returns {string | undefined}
     */
    getTarget(appIdKey, pageIdKey) {
        if (!appIdKey || !pageIdKey) {
            return;
        }
        return this.targets[appIdKey]?.[pageIdKey];
    }
    /**
     * @param {import('../types').AppIdKey} appIdKey
     * @param {import('../types').PageIdKey} pageIdKey
     * @param {PageReadinessDetector} [pageReadinessDetector]
     * @returns {Promise<void>}
     */
    async selectPage(appIdKey, pageIdKey, pageReadinessDetector) {
        await this._pageSelectionLock.acquire(toPageSelectionKey(appIdKey, pageIdKey), async () => {
            this._pendingTargetNotification = [appIdKey, pageIdKey, pageReadinessDetector];
            this._provisionedPages.clear();
            // go through the steps that the Desktop Safari system
            // goes through to initialize the Web Inspector session
            const sendOpts = {
                appIdKey,
                pageIdKey,
            };
            const timeoutMs = Math.trunc(Math.max(this.pageLoadTimeoutMs ?? 0, PAGE_INIT_TIMEOUT_MS) * 1.2);
            const timer = new support_1.timing.Timer().start();
            const setupWebview = async () => {
                // highlight and then un-highlight the webview
                for (const enabled of [true, false]) {
                    await this.send('indicateWebView', Object.assign({
                        enabled,
                    }, sendOpts), false);
                }
                await this.send('setSenderKey', sendOpts);
            };
            await bluebird_1.default.resolve(setupWebview())
                .timeout(timeoutMs, `Cannot set up page '${pageIdKey}' for app '${appIdKey}' within ${timeoutMs}ms`);
            const msLeft = Math.max(timeoutMs - Math.trunc(timer.getDuration().asMilliSeconds), 1000);
            logger_1.default.debug(`Waiting up to ${msLeft}ms for page '${pageIdKey}' of app '${appIdKey}' to be selected`);
            await new Promise((resolve) => {
                const onPageInitialized = (
                /** @type {import("../types").AppIdKey} */ notifiedAppIdKey, 
                /** @type {import("../types").PageIdKey} */ notifiedPageIdKey) => {
                    const timeoutHandler = setTimeout(() => {
                        this._pageSelectionMonitor.off(ON_PAGE_INITIALIZED_EVENT, onPageInitialized);
                        logger_1.default.warn(`Page '${pageIdKey}' for app '${appIdKey}' has not been selected ` +
                            `within ${timer.getDuration().asMilliSeconds}ms. Continuing anyway`);
                        resolve(false);
                    }, msLeft);
                    if (notifiedAppIdKey === appIdKey && notifiedPageIdKey === pageIdKey) {
                        clearTimeout(timeoutHandler);
                        this._pageSelectionMonitor.off(ON_PAGE_INITIALIZED_EVENT, onPageInitialized);
                        logger_1.default.debug(`Selected the page ${pageIdKey}@${appIdKey} after ${timer.getDuration().asMilliSeconds}ms`);
                        resolve(true);
                    }
                    else {
                        logger_1.default.debug(`Got notified that page ${notifiedPageIdKey}@${notifiedAppIdKey} is initialized, ` +
                            `but we are waiting for ${pageIdKey}@${appIdKey}. Continuing to wait`);
                    }
                };
                this._pageSelectionMonitor.on(ON_PAGE_INITIALIZED_EVENT, onPageInitialized);
            });
        });
    }
    /**
     * Mimic every step that Desktop Safari Develop tools uses to initialize a
     * Web Inspector session
     *
     * @param {import('../types').AppIdKey} appIdKey
     * @param {import('../types').PageIdKey} pageIdKey
     * @param {import('../types').TargetId} [targetId]
     * @returns {Promise<boolean>}
     */
    async _initializePage(appIdKey, pageIdKey, targetId) {
        const sendOpts = {
            appIdKey,
            pageIdKey,
            targetId,
        };
        logger_1.default.debug(`Initializing page '${pageIdKey}' for app '${appIdKey}'`);
        const timer = new support_1.timing.Timer().start();
        if (!this.fullPageInitialization) {
            // The sequence of domains is important
            for (const domain of [
                'Inspector.enable',
                'Page.enable',
                'Runtime.enable',
                'Network.enable',
                'Heap.enable',
                'Debugger.enable',
                'Console.enable',
                'Inspector.initialized',
            ]) {
                try {
                    await this.send(domain, sendOpts);
                }
                catch (err) {
                    logger_1.default.info(`Cannot enable domain '${domain}' during initialization: ${err.message}`);
                    if (MISSING_TARGET_ERROR_PATTERN.test(err.message)) {
                        return false;
                    }
                }
            }
            logger_1.default.debug(`Simple initialization of page '${pageIdKey}' for app '${appIdKey}' completed ` +
                `in ${timer.getDuration().asMilliSeconds}ms`);
            return true;
        }
        // The sequence of commands here is important
        const domainsToOptsMap = {
            'Inspector.enable': sendOpts,
            'Page.enable': sendOpts,
            'Runtime.enable': sendOpts,
            'Page.getResourceTree': sendOpts,
            'Network.enable': sendOpts,
            'Network.setResourceCachingDisabled': {
                disabled: false,
                ...sendOpts,
            },
            'DOMStorage.enable': sendOpts,
            'Database.enable': sendOpts,
            'IndexedDB.enable': sendOpts,
            'CSS.enable': sendOpts,
            'Heap.enable': sendOpts,
            'Memory.enable': sendOpts,
            'ApplicationCache.enable': sendOpts,
            'ApplicationCache.getFramesWithManifests': sendOpts,
            'Timeline.setInstruments': {
                instruments: ['Timeline', 'ScriptProfiler', 'CPU'],
                ...sendOpts,
            },
            'Timeline.setAutoCaptureEnabled': {
                enabled: false,
                ...sendOpts,
            },
            'Debugger.enable': sendOpts,
            'Debugger.setBreakpointsActive': {
                active: true,
                ...sendOpts,
            },
            'Debugger.setPauseOnExceptions': {
                state: 'none',
                ...sendOpts,
            },
            'Debugger.setPauseOnAssertions': {
                enabled: false,
                ...sendOpts,
            },
            'Debugger.setAsyncStackTraceDepth': {
                depth: 200,
                ...sendOpts,
            },
            'Debugger.setPauseForInternalScripts': {
                shouldPause: false,
                ...sendOpts,
            },
            'LayerTree.enable': sendOpts,
            'Worker.enable': sendOpts,
            'Canvas.enable': sendOpts,
            'Console.enable': sendOpts,
            'DOM.getDocument': sendOpts,
            'Console.getLoggingChannels': sendOpts,
            'Inspector.initialized': sendOpts,
        };
        for (const [domain, opts] of Object.entries(domainsToOptsMap)) {
            try {
                const res = await this.send(domain, opts);
                if (domain === 'Console.getLoggingChannels') {
                    for (const source of (res?.channels || []).map((/** @type {{ source: any; }} */ entry) => entry.source)) {
                        try {
                            await this.send('Console.setLoggingChannelLevel', Object.assign({
                                source,
                                level: 'verbose',
                            }, sendOpts));
                        }
                        catch (err) {
                            logger_1.default.info(`Cannot set logging channel level for '${source}': ${err.message}`);
                            if (MISSING_TARGET_ERROR_PATTERN.test(err.message)) {
                                return false;
                            }
                        }
                    }
                }
            }
            catch (err) {
                logger_1.default.info(`Cannot enable domain '${domain}' during full initialization: ${err.message}`);
                if (MISSING_TARGET_ERROR_PATTERN.test(err.message)) {
                    return false;
                }
            }
        }
        logger_1.default.debug(`Full initialization of page '${pageIdKey}' for app '${appIdKey}' completed ` +
            `in ${timer.getDuration().asMilliSeconds}ms`);
        return true;
    }
    /**
     *
     * @param {import('../types').AppIdKey} appIdKey
     * @returns {Promise<[string, Record<string, any>]>}
     */
    async selectApp(appIdKey) {
        return await new bluebird_1.default((resolve, reject) => {
            // local callback, temporarily added as callback to
            // `_rpc_applicationConnected:` remote debugger response
            // to handle the initial connection
            const onAppChange = (err, dict) => {
                if (err) {
                    return reject(err);
                }
                // from the dictionary returned, get the ids
                const oldAppIdKey = dict.WIRHostApplicationIdentifierKey;
                const correctAppIdKey = dict.WIRApplicationIdentifierKey;
                // if this is a report of a proxy redirect from the remote debugger
                // we want to update our dictionary and get a new app id
                if (oldAppIdKey && correctAppIdKey !== oldAppIdKey) {
                    logger_1.default.debug(`We were notified we might have connected to the wrong app. ` +
                        `Using id ${correctAppIdKey} instead of ${oldAppIdKey}`);
                }
                reject(new Error(exports.NEW_APP_CONNECTED_ERROR));
            };
            this.messageHandler?.prependOnceListener('_rpc_applicationConnected:', onAppChange);
            // do the actual connecting to the app
            (async () => {
                try {
                    const [connectedAppIdKey, pageDict] = await this.send('connectToApp', { appIdKey });
                    // sometimes the connect logic happens, but with an empty dictionary
                    // which leads to the remote debugger getting disconnected, and into a loop
                    if (lodash_1.default.isEmpty(pageDict)) {
                        reject(new Error(exports.EMPTY_PAGE_DICTIONARY_ERROR));
                    }
                    else {
                        resolve([connectedAppIdKey, pageDict]);
                    }
                }
                catch (err) {
                    logger_1.default.warn(`Unable to connect to the app: ${err.message}`);
                    reject(err);
                }
                finally {
                    this.messageHandler?.off('_rpc_applicationConnected:', onAppChange);
                }
            })();
        });
    }
    /**
     *
     * @param {Error?} err
     * @param {Record<string, any>} context
     */
    onExecutionContextCreated(err, context) {
        // { id: 2, isPageContext: true, name: '', frameId: '0.1' }
        // right now we have no way to map contexts to apps/pages
        // so just store
        this.contexts.push(context.id);
    }
    /**
     * @returns {void}
     */
    onGarbageCollected() {
        // just want to log that this is happening, as it can affect opertion
        logger_1.default.debug(`Web Inspector garbage collected`);
    }
    /**
     *
     * @param {Error?} err
     * @param {Record<string, any>} scriptInfo
     */
    onScriptParsed(err, scriptInfo) {
        // { scriptId: '13', url: '', startLine: 0, startColumn: 0, endLine: 82, endColumn: 3 }
        logger_1.default.debug(`Script parsed: ${JSON.stringify(scriptInfo)}`);
    }
    /**
     *
     * @param {import('../types').AppIdKey} appIdKey
     * @param {import('../types').PageIdKey} pageIdKey
     * @param {import('../types').TargetId} targetId
     * @returns {Promise<void>}
     */
    async _resumeTarget(appIdKey, pageIdKey, targetId) {
        try {
            await this.send('Target.resume', {
                appIdKey,
                pageIdKey,
                targetId,
            });
            logger_1.default.debug(`Successfully resumed the target ${targetId}@${appIdKey}`);
        }
        catch (e) {
            logger_1.default.warn(`Could not resume the target ${targetId}@${appIdKey}: ${e.message}`);
        }
    }
    /**
     *
     * @param {import('../types').AppIdKey} appIdKey
     * @param {import('../types').PageIdKey} pageIdKey
     * @param {import('../types').TargetId} targetId
     * @param {PageReadinessDetector} [pageReadinessDetector]
     * @returns {Promise<void>}
     */
    async _waitForPageReadiness(appIdKey, pageIdKey, targetId, pageReadinessDetector) {
        if (!pageReadinessDetector) {
            return;
        }
        logger_1.default.debug(`Waiting up to ${pageReadinessDetector.timeoutMs}ms for page readiness`);
        const timer = new support_1.timing.Timer().start();
        while (pageReadinessDetector.timeoutMs - timer.getDuration().asMilliSeconds > 0) {
            /** @type {string} */
            let readyState;
            try {
                const commandTimeoutMs = Math.max(100, Math.trunc((pageReadinessDetector.timeoutMs - timer.getDuration().asMilliSeconds) * 0.8));
                const rawResult = await bluebird_1.default.resolve(this.send('Runtime.evaluate', {
                    expression: 'document.readyState;',
                    returnByValue: true,
                    appIdKey,
                    pageIdKey,
                    targetId,
                })).timeout(commandTimeoutMs);
                readyState = (0, utils_1.convertJavascriptEvaluationResult)(rawResult);
            }
            catch (e) {
                logger_1.default.debug(`Cannot determine page readiness: ${e.message}`);
                continue;
            }
            if (pageReadinessDetector.readinessDetector(readyState)) {
                logger_1.default.info(`Page '${pageIdKey}' for app '${appIdKey}' is ready after ` +
                    `${timer.getDuration().asMilliSeconds}ms`);
                return;
            }
            await bluebird_1.default.delay(100);
        }
        logger_1.default.warn(`Page '${pageIdKey}' for app '${appIdKey}' is not ready after ` +
            `${timer.getDuration().asMilliSeconds}ms. Continuing anyway`);
    }
    /**
     *
     * @param {import('../types').AppIdKey} appIdKey
     * @param {import('../types').PageIdKey} pageIdKey
     * @returns {Promise<void>}
     */
    async waitForPage(appIdKey, pageIdKey) {
        const appTargetsMap = this.targets[appIdKey];
        if (!appTargetsMap) {
            throw new Error(`No targets found for app '${appIdKey}'`);
        }
        const lock = appTargetsMap.lock;
        const timer = new support_1.timing.Timer().start();
        await Promise.all([
            lock.acquire(pageIdKey, async () => await bluebird_1.default.delay(0)),
            this._pageSelectionLock.acquire(toPageSelectionKey(appIdKey, pageIdKey), async () => await bluebird_1.default.delay(0))
        ]);
        const durationMs = timer.getDuration().asMilliSeconds;
        if (durationMs > 10) {
            logger_1.default.debug(`Waited ${durationMs}ms until the page ${pageIdKey}@${appIdKey} is initialized`);
        }
    }
}
exports.RpcClient = RpcClient;
/**
 *
 * @param {import('../types').AppIdKey} appIdKey
 * @param {import('../types').PageIdKey} pageIdKey
 * @returns {string}
 */
function toPageSelectionKey(appIdKey, pageIdKey) {
    return `${appIdKey}:${pageIdKey}`;
}
exports.default = RpcClient;
/**
 * @typedef {Object} RpcClientOptions
 * @property {string} [bundleId]
 * @property {string} [platformVersion='']
 * @property {boolean} [isSafari=true]
 * @property {boolean} [logAllCommunication=false]
 * @property {boolean} [logAllCommunicationHexDump=false]
 * @property {number} [webInspectorMaxFrameLength]
 * @property {number} [socketChunkSize]
 * @property {boolean} [fullPageInitialization=false]
 * @property {number} [pageLoadTimeoutMs]
 * @property {string} [udid]
 */
/**
 * @typedef {{[key: import('../types').PageIdKey]: import('../types').TargetId}} PageDict
 */
/**
 * @typedef {PageDict & {provisional?: import('../types').ProvisionalTargetInfo, lock: AsyncLock}} PagesToTargets
 * @typedef {{[key: import('../types').AppIdKey]: PagesToTargets}} AppToTargetsMap
 */
/**
 * @typedef {Object} PageReadinessDetector
 * @property {number} timeoutMs
 * @property {(readyState: string) => boolean} readinessDetector
 */
/**
 * @typedef {[import('../types').AppIdKey, import('../types').PageIdKey, PageReadinessDetector | undefined]} PendingTargetNotification
 */
//# sourceMappingURL=rpc-client.js.map