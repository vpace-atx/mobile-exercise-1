export default class RpcMessageHandler extends EventEmitters<[never]> {
    constructor();
    /**
     * Handle a message from the Web Inspector.
     *
     * @param {import('@appium/types').StringRecord} plist
     * @returns {Promise<void>}
     */
    handleMessage(plist: import("@appium/types").StringRecord): Promise<void>;
    /**
     * Parse the data key from the plist.
     *
     * @param {import('@appium/types').StringRecord} plist
     * @returns {DataMessage}
     * @throws {Error} if the data key cannot be parsed
     */
    parseDataKey(plist: import("@appium/types").StringRecord): DataMessage;
    /**
     * Dispatch a data message.
     *
     * @param {string} msgId If not empty then the following event is going to be emitted:
     * - <msgId, error, result>
     * If empty then the following event is going to be emitted:
     * - <name, error, ..args>
     * @param {string | undefined} method
     * @param {import('@appium/types').StringRecord | undefined} params
     * @param {any} result
     * @param {Error | undefined} error
     * @returns {Promise<void>}
     */
    dispatchDataMessage(msgId: string, method: string | undefined, params: import("@appium/types").StringRecord | undefined, result: any, error: Error | undefined): Promise<void>;
    /**
     * Handle a data message from the Web Inspector.
     *
     * @param {import('@appium/types').StringRecord} plist
     * @returns {Promise<void>}
     */
    handleDataMessage(plist: import("@appium/types").StringRecord): Promise<void>;
}
export type DataMessage = {
    id?: string | undefined;
    method: string;
    params: import("@appium/types").StringRecord;
    result: any;
    error?: string | DataErrorMessage | undefined;
};
export type DataErrorMessage = {
    message: string;
    code: number;
    data: any;
};
import EventEmitters from 'events';
//# sourceMappingURL=rpc-message-handler.d.ts.map