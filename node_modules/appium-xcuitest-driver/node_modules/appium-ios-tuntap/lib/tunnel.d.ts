import { TunTap } from './TunTap.js';
import { EventEmitter } from 'events';
import { Socket } from 'net';
import { Buffer } from 'buffer';
interface TunnelClientParameters {
    address: string;
    mtu: number;
}
interface TunnelInfo {
    clientParameters: TunnelClientParameters;
    serverAddress: string;
    serverRSDPort?: number;
}
export interface PacketData {
    protocol: 'TCP' | 'UDP';
    src: string;
    dst: string;
    sourcePort: number;
    destPort: number;
    payload: Buffer;
}
export interface PacketConsumer {
    onPacket(packet: PacketData): void;
}
export interface TunnelConnection {
    Address: string;
    RsdPort?: number;
    tunnelManager: TunnelManager;
    closer: () => Promise<void>;
    addPacketConsumer(consumer: PacketConsumer): void;
    removePacketConsumer(consumer: PacketConsumer): void;
    getPacketStream(): AsyncIterable<PacketData>;
}
export declare class TunnelManager extends EventEmitter {
    private tun;
    private cancelled;
    private readInterval;
    private buffer;
    private packetConsumers;
    private packetQueue;
    private deviceConn;
    private cleanupPromise;
    constructor();
    addPacketConsumer(consumer: PacketConsumer): void;
    removePacketConsumer(consumer: PacketConsumer): void;
    getPacketStream(): AsyncIterable<PacketData>;
    setupInterface(tunnelInfo: TunnelInfo): Promise<{
        name: string;
        mtu: number;
        interface: TunTap;
    }>;
    startForwarding(deviceConn: Socket): void;
    private processBuffer;
    private startTunReadLoop;
    stop(): Promise<void>;
    private _performStop;
}
export declare function exchangeCoreTunnelParameters(socket: Socket): Promise<TunnelInfo>;
export declare function connectToTunnelLockdown(secureServiceSocket: Socket): Promise<TunnelConnection>;
export {};
