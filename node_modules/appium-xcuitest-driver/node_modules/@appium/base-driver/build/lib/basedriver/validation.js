"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validator = exports.Validator = void 0;
const logger_1 = __importDefault(require("./logger"));
const lodash_1 = __importDefault(require("lodash"));
class Validator {
    _validators = {
        isString: (value, options) => {
            if (lodash_1.default.isUndefined(value) || lodash_1.default.isNil(options)) {
                return null;
            }
            if (lodash_1.default.isString(value)) {
                return options ? null : 'must not be of type string';
            }
            return options ? 'must be of type string' : null;
        },
        isNumber: (value, options) => {
            if (lodash_1.default.isUndefined(value) || lodash_1.default.isNil(options)) {
                return null;
            }
            if (lodash_1.default.isNumber(value)) {
                return options ? null : 'must not be of type number';
            }
            // allow a string value
            if (options && lodash_1.default.isString(value) && !isNaN(Number(value))) {
                logger_1.default.warn('Number capability passed in as string. Functionality may be compromised.');
                return null;
            }
            return options ? 'must be of type number' : null;
        },
        isBoolean: (value, options) => {
            if (lodash_1.default.isUndefined(value) || lodash_1.default.isNil(options)) {
                return null;
            }
            if (lodash_1.default.isBoolean(value)) {
                return options ? null : 'must not be of type boolean';
            }
            // allow a string value
            if (options && lodash_1.default.isString(value) && ['true', 'false', ''].includes(value)) {
                return null;
            }
            return options ? 'must be of type boolean' : null;
        },
        isObject: (value, options) => {
            if (lodash_1.default.isUndefined(value) || lodash_1.default.isNil(options)) {
                return null;
            }
            if (lodash_1.default.isPlainObject(value)) {
                return options ? null : 'must not be a plain object';
            }
            return options ? 'must be a plain object' : null;
        },
        isArray: (value, options) => {
            if (lodash_1.default.isUndefined(value) || lodash_1.default.isNil(options)) {
                return null;
            }
            if (lodash_1.default.isArray(value)) {
                return options ? null : 'must not be of type array';
            }
            return options ? 'must be of type array' : null;
        },
        deprecated: (value, options, key) => {
            if (!lodash_1.default.isUndefined(value) && options) {
                logger_1.default.warn(`The '${key}' capability has been deprecated and must not be used anymore. ` +
                    `Please check the driver documentation for possible alternatives.`);
            }
            return null;
        },
        inclusion: (value, options) => {
            if (lodash_1.default.isUndefined(value) || !options) {
                return null;
            }
            const optionsArr = lodash_1.default.isArray(options) ? options : [options];
            if (optionsArr.some((opt) => opt === value)) {
                return null;
            }
            return `must be contained by ${JSON.stringify(optionsArr)}`;
        },
        inclusionCaseInsensitive: (value, options) => {
            if (lodash_1.default.isUndefined(value) || !options) {
                return null;
            }
            const optionsArr = lodash_1.default.isArray(options) ? options : [options];
            if (optionsArr.some((opt) => lodash_1.default.toLower(opt) === lodash_1.default.toLower(value))) {
                return null;
            }
            return `must be contained by ${JSON.stringify(optionsArr)}`;
        },
        presence: (value, options) => {
            if (lodash_1.default.isUndefined(value) && options) {
                return 'is required to be present';
            }
            if (!options?.allowEmpty &&
                ((!lodash_1.default.isUndefined(value) && lodash_1.default.isEmpty(value)) || (lodash_1.default.isString(value) && !lodash_1.default.trim(value)))) {
                return 'must not be empty or blank';
            }
            return null;
        }
    };
    validate(values, constraints) {
        const result = {};
        for (const [key, constraint] of lodash_1.default.toPairs(constraints)) {
            const value = values[key];
            for (const [validatorName, options] of lodash_1.default.toPairs(constraint)) {
                if (!(validatorName in this._validators)) {
                    continue;
                }
                const validationError = this._validators[validatorName](value, options, key);
                if (lodash_1.default.isNil(validationError)) {
                    continue;
                }
                if (key in result) {
                    result[key].push(validationError);
                }
                else {
                    result[key] = [validationError];
                }
            }
        }
        return lodash_1.default.isEmpty(result) ? null : result;
    }
}
exports.Validator = Validator;
exports.validator = new Validator();
//# sourceMappingURL=validation.js.map