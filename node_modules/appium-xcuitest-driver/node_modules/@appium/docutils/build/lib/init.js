"use strict";
/**
 * Scaffolding functions for CLI `init` command
 *
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initMkDocs = void 0;
exports.initPython = initPython;
exports.init = init;
const constants_1 = require("./constants");
const yaml_1 = __importDefault(require("yaml"));
const teen_process_1 = require("teen_process");
const error_1 = require("./error");
const scaffold_1 = require("./scaffold");
const logger_1 = require("./logger");
const fs_1 = require("./fs");
/**
 * Data for the base `mkdocs.yml` file
 */
const BASE_MKDOCS_YML = Object.freeze({
    INHERIT: './node_modules/@appium/docutils/base-mkdocs.yml',
    docs_dir: 'docs',
    site_dir: 'site',
});
const log = (0, logger_1.getLogger)('init');
const dryRunLog = (0, logger_1.getLogger)('dry-run', log);
/**
 * Function which scaffolds an `mkdocs.yml` file
 */
exports.initMkDocs = (0, scaffold_1.createScaffoldTask)(constants_1.NAME_MKDOCS_YML, BASE_MKDOCS_YML, 'MkDocs configuration', {
    deserialize: yaml_1.default.parse,
    serialize: fs_1.stringifyYaml,
    transform: (content, opts, pkg) => {
        let siteName = opts.siteName ?? content.site_name;
        if (!siteName) {
            siteName = pkg.name ?? '(no name)';
            if (siteName) {
                log.info('Using site name from package.json: %s', siteName);
            }
        }
        let repoUrl = opts.repoUrl ?? content.repo_url;
        if (!repoUrl) {
            repoUrl = pkg.repository?.url;
            if (repoUrl) {
                log.info('Using repo URL from package.json: %s', repoUrl);
            }
        }
        let repoName = opts.repoName ?? content.repo_name;
        if (repoUrl && !repoName) {
            let { pathname } = new URL(repoUrl);
            pathname = pathname.slice(1);
            const pathparts = pathname.split('/');
            const owner = pathparts[0];
            let repo = pathparts[1];
            repo = repo.replace(/\.git$/, '');
            repoName = [owner, repo].join('/');
            if (repoName) {
                log.info('Using repo name from package.json: %s', repoName);
            }
        }
        let siteDescription = opts.siteDescription ?? content.site_description;
        if (!siteDescription) {
            siteDescription = pkg.description;
            if (siteDescription) {
                log.info('Using site description URL from package.json: %s', siteDescription);
            }
        }
        return {
            ...content,
            site_name: siteName,
            repo_url: repoUrl,
            repo_name: repoName,
            site_description: siteDescription,
        };
    },
});
/**
 * Installs Python dependencies
 * @param opts Options
 */
async function initPython({ pythonPath, dryRun = false, upgrade = false, } = {}) {
    const foundPythonPath = await (0, fs_1.requirePython)(pythonPath);
    const args = ['-m', 'pip', 'install', '-r', constants_1.REQUIREMENTS_TXT_PATH];
    if (upgrade) {
        args.push('--upgrade');
    }
    if (dryRun) {
        dryRunLog.info('Would execute command: %s %s (environment variables: %s)', foundPythonPath, args.join(' '), constants_1.PIP_ENV_VARS);
    }
    else {
        log.debug('Executing command: %s %s (environment variables: %s)', foundPythonPath, args.join(' '), constants_1.PIP_ENV_VARS);
        log.info('Installing Python dependencies...');
        try {
            const result = await (0, teen_process_1.exec)(foundPythonPath, args, { env: constants_1.PIP_ENV_VARS, shell: true });
            const { code, stdout } = result;
            if (code !== 0) {
                throw new error_1.DocutilsError(`Could not install Python dependencies. Reason: ${stdout}`);
            }
        }
        catch (err) {
            throw new error_1.DocutilsError(`Could not install Python dependencies. Reason: ${err.message}`);
        }
    }
    log.success('Successfully installed Python dependencies');
}
/**
 * Main handler for `init` command.
 *
 * This runs tasks in serial; it _could_ run in parallel, but it has deleterious effects upon
 * console output which would need mitigation.
 */
async function init({ python, packageJson: packageJsonPath, overwrite, mkdocs, mkdocsYml: mkdocsYmlPath, siteName, repoName, repoUrl, copyright, dryRun, cwd, pythonPath, upgrade, } = {}) {
    if (python) {
        await initPython({ pythonPath, dryRun, upgrade });
    }
    if (mkdocs && !upgrade) {
        await (0, exports.initMkDocs)({
            dest: mkdocsYmlPath,
            cwd,
            siteName,
            repoUrl,
            repoName,
            copyright,
            packageJson: packageJsonPath,
            overwrite,
            dryRun,
        });
    }
}
//# sourceMappingURL=init.js.map