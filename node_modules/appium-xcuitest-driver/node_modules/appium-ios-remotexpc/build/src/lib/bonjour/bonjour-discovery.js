import { logger } from '@appium/support';
import { spawn } from 'node:child_process';
import { resolve4 } from 'node:dns/promises';
import { EventEmitter } from 'node:events';
import { clearTimeout, setTimeout } from 'node:timers';
import { setTimeout as delay } from 'node:timers/promises';
import { BONJOUR_DEFAULT_DOMAIN, BONJOUR_SERVICE_TYPES, BONJOUR_TIMEOUTS, DNS_SD_ACTIONS, DNS_SD_COMMANDS, DNS_SD_PATTERNS, } from './constants.js';
const log = logger.getLogger('BonjourDiscovery');
const DNS_SD_COMMAND = 'dns-sd';
/**
 * Execute a dns-sd command with a timeout.
 *
 * @param args Arguments passed to the dns-sd CLI.
 * @param timeoutMs Timeout in milliseconds.
 * @param outputHandler Called for each stdout chunk from dns-sd:
 *   - returns true: chunk handled; no result recorded; continue listening
 *   - returns a truthy non-true value (e.g., object): store as result to return when the process ends
 *   - returns false/undefined/null: ignore; continue listening
 *   - throws: mark command as failed
 * @param timeoutMessage Error message used if the command times out.
 * @returns The value produced by outputHandler, if any, when the process ends.
 */
async function executeDnsSdCommand(args, timeoutMs, outputHandler, timeoutMessage) {
    const child = spawn(DNS_SD_COMMAND, args);
    try {
        const result = await waitForProcessResult(child, timeoutMs, outputHandler, timeoutMessage);
        if (!result.success) {
            throw result.error || new Error('Process execution failed');
        }
        return result.data;
    }
    finally {
        if (!child.killed) {
            child.kill('SIGTERM');
        }
    }
}
/**
 * Create a long-running browse process
 */
function createDnsSdBrowseProcess(serviceType, domain) {
    return spawn(DNS_SD_COMMAND, [DNS_SD_COMMANDS.BROWSE, serviceType, domain]);
}
/**
 * Wait for a child process result with a timeout.
 *
 * @param process Child process to observe.
 * @param timeoutMs Timeout in milliseconds.
 * @param outputHandler Called for each stdout chunk from dns-sd:
 *   - returns true: chunk handled; no result recorded; continue listening
 *   - returns a truthy non-true value (e.g., object): store as result to return when the process ends
 *   - returns false/undefined/null: ignore; continue listening
 *   - throws: mark command as failed
 * @param timeoutMessage Error message used if the operation times out.
 * @returns A ProcessResult indicating success and any data from outputHandler.
 */
async function waitForProcessResult(process, timeoutMs, outputHandler, timeoutMessage) {
    return new Promise((resolve, reject) => {
        let isResolved = false;
        let result;
        let exitCode = null;
        let hasError = false;
        let errorMessage = '';
        const timeout = setTimeout(() => {
            if (!isResolved) {
                isResolved = true;
                reject(new Error(timeoutMessage));
            }
        }, timeoutMs);
        const cleanup = () => {
            clearTimeout(timeout);
            if (!isResolved) {
                isResolved = true;
                if (hasError) {
                    reject(new Error(errorMessage));
                }
                else if (exitCode !== null && exitCode !== 0) {
                    reject(new Error(`Process exited with code ${exitCode}`));
                }
                else if (result !== undefined) {
                    resolve({ success: true, data: result });
                }
                else {
                    resolve({ success: true });
                }
            }
        };
        process.stdout?.on('data', (data) => {
            if (isResolved) {
                return;
            }
            const output = data.toString();
            log.debug(`[dns-sd] output: ${output}`);
            try {
                const handlerResult = outputHandler(output);
                if (handlerResult === true) {
                    result = undefined;
                }
                else if (handlerResult) {
                    result = handlerResult;
                }
            }
            catch (error) {
                hasError = true;
                errorMessage = `Output handler error: ${error}`;
            }
        });
        process.stderr?.on('data', (data) => {
            if (isResolved) {
                return;
            }
            const error = data.toString();
            log.error(`[dns-sd] error: ${error}`);
            hasError = true;
            errorMessage = `Process failed: ${error}`;
        });
        process.on('error', (error) => {
            if (isResolved) {
                return;
            }
            log.error(`[dns-sd] failed to start process: ${error}`);
            hasError = true;
            errorMessage = `Failed to start process: ${error}`;
        });
        process.on('exit', (code) => {
            exitCode = code;
            if (code !== null && code !== 0) {
                log.error(`[dns-sd] process exited with error code: ${code}`);
            }
        });
        process.on('close', (code) => {
            log.debug(`[dns-sd] process closed with code: ${code}`);
            cleanup();
        });
    });
}
/**
 * Parse browse output and extract service information
 */
function parseBrowseOutput(output) {
    const reducer = (acc, line) => {
        const match = line.match(DNS_SD_PATTERNS.BROWSE_LINE);
        if (!match) {
            return acc;
        }
        const [, , action, , interfaceIndex, domain, serviceType, name] = match;
        const trimmedName = name.trim();
        const service = {
            name: trimmedName,
            type: serviceType,
            domain,
            interfaceIndex: parseInt(interfaceIndex, 10),
        };
        acc.push({ action, service });
        return acc;
    };
    return output
        .split('\n')
        .filter((line) => !shouldSkipLine(line))
        .reduce(reducer, []);
}
/**
 * Parse resolve output and extract service details
 */
function parseResolveOutput(output, serviceName, serviceType, domain) {
    return parseOutput(output, (line, result) => {
        // If we already found a result, return it (early termination)
        if (result) {
            return result;
        }
        const reachableMatch = line.match(DNS_SD_PATTERNS.REACHABLE);
        if (reachableMatch) {
            const [, hostname, port, interfaceIndex] = reachableMatch;
            const txtRecord = parseTxtRecord(output);
            return {
                name: serviceName,
                type: serviceType,
                domain,
                hostname,
                port: parseInt(port, 10),
                txtRecord,
                interfaceIndex: parseInt(interfaceIndex, 10),
            };
        }
        return result;
    }, null);
}
/**
 * Generic method to parse output with different reducer functions
 */
function parseOutput(output, reducer, initialValue) {
    const lines = output.split('\n');
    let result = initialValue;
    for (const line of lines) {
        if (shouldSkipLine(line)) {
            continue;
        }
        result = reducer(line, result);
    }
    return result;
}
/**
 * Parse TXT record from output
 */
function parseTxtRecord(output) {
    const txtRecord = {};
    const txtMatch = output.match(DNS_SD_PATTERNS.TXT_RECORD);
    if (txtMatch) {
        const [, identifier, authTag, model, name, ver, minVer] = txtMatch;
        txtRecord.identifier = identifier;
        txtRecord.authTag = authTag;
        txtRecord.model = model;
        txtRecord.name = name;
        txtRecord.ver = ver;
        txtRecord.minVer = minVer;
    }
    return txtRecord;
}
/**
 * Check if line should be skipped
 */
function shouldSkipLine(line) {
    return (line.includes('Timestamp') || line.includes('---') || line.trim() === '');
}
/**
 * Resolve hostname to IP address
 */
async function resolveIPAddress(hostname) {
    try {
        const address = await resolve4(hostname);
        log.info(`[ServiceResolver] Resolved ${hostname} to IPv4: ${address}`);
        return address;
    }
    catch (error) {
        log.warn(`[ServiceResolver] Failed to resolve hostname ${hostname} to IPv4: ${error}`);
        // For .local hostnames, try without the trailing dot
        if (hostname.endsWith('.local.')) {
            const cleanHostname = hostname.slice(0, -1); // Remove trailing dot
            try {
                const address = await resolve4(cleanHostname);
                log.info(`[ServiceResolver] Resolved ${cleanHostname} to IPv4: ${address}`);
                return address;
            }
            catch (retryError) {
                log.warn(`[ServiceResolver] Failed to resolve ${cleanHostname} to IPv4: ${retryError}`);
            }
        }
        return undefined;
    }
}
/**
 * Convert a resolved Bonjour service to an Apple TV device with IP resolution
 */
async function convertToAppleTVDeviceWithIP(service) {
    if (!isValidService(service)) {
        return null;
    }
    const { txtRecord, hostname, port } = service;
    if (!txtRecord || !hasRequiredTxtFields(txtRecord)) {
        log.warn(`[AppleTVDeviceConverter] Service ${service.name} missing required TXT record fields`);
        return null;
    }
    if (!hostname || !port) {
        log.warn(`[AppleTVDeviceConverter] Service ${service.name} missing hostname or port`);
        return null;
    }
    const ipAddresses = await resolveIPAddress(hostname);
    // Select default first one
    // TODO: needs a decision to select from cli, if the user wants to select from the available ip's
    const ip = ipAddresses?.[0];
    return {
        name: service.name,
        identifier: txtRecord.identifier,
        hostname,
        ip,
        port,
        model: txtRecord.model,
        version: txtRecord.ver,
        minVersion: txtRecord.minVer || '17',
        authTag: txtRecord.authTag,
        interfaceIndex: service.interfaceIndex,
    };
}
/**
 * Check if the service has required fields
 */
function isValidService(service) {
    return Boolean(service.hostname && service.port && service.txtRecord);
}
/**
 * Check if TXT record has required fields
 */
function hasRequiredTxtFields(txtRecord) {
    return Boolean(txtRecord.identifier && txtRecord.model && txtRecord.ver);
}
/* =========================
 * Main Bonjour discovery service orchestrator
 * =========================
 */
export class BonjourDiscovery extends EventEmitter {
    _browseProcess;
    _isDiscovering = false;
    _discoveredServices = new Map();
    /**
     * Start browsing for Bonjour services
     */
    async startBrowsing(serviceType = BONJOUR_SERVICE_TYPES.APPLE_TV_PAIRING, domain = BONJOUR_DEFAULT_DOMAIN) {
        if (this._isDiscovering) {
            log.warn('Already discovering services');
            return;
        }
        log.info(`Starting Bonjour discovery for ${serviceType}.${domain}`);
        try {
            await this.initializeBrowsing(serviceType, domain);
        }
        catch (error) {
            this.cleanup();
            throw error;
        }
    }
    /**
     * Stop browsing for services
     */
    stopBrowsing() {
        if (this._browseProcess && !this._browseProcess.killed) {
            log.info('Stopping Bonjour discovery');
            this._browseProcess.kill('SIGTERM');
        }
        this.cleanup();
    }
    /**
     * Get all discovered services
     */
    getDiscoveredServices() {
        return Array.from(this._discoveredServices.values());
    }
    /**
     * Resolve a specific service to get detailed information
     */
    async resolveService(serviceName, serviceType = BONJOUR_SERVICE_TYPES.APPLE_TV_PAIRING, domain = BONJOUR_DEFAULT_DOMAIN) {
        log.info(`[ServiceResolver] Resolving service: ${serviceName}.${serviceType}.${domain}`);
        const service = await executeDnsSdCommand([DNS_SD_COMMANDS.RESOLVE, serviceName, serviceType, domain], BONJOUR_TIMEOUTS.SERVICE_RESOLUTION, (output) => parseResolveOutput(output, serviceName, serviceType, domain), `Service resolution timeout for ${serviceName}`);
        if (!service) {
            throw new Error(`Failed to resolve service ${serviceName}`);
        }
        return service;
    }
    /**
     * Discover Apple TV devices with IP address resolution
     */
    async discoverAppleTVDevicesWithIP(timeoutMs = BONJOUR_TIMEOUTS.DEFAULT_DISCOVERY) {
        log.info('Starting Apple TV device discovery with IP resolution');
        try {
            await this.startBrowsing();
            await delay(timeoutMs);
            const devices = await this.resolveAllServices();
            log.info(`Discovered ${devices.length} Apple TV device(s) with IP addresses:`, devices);
            return devices;
        }
        finally {
            this.stopBrowsing();
        }
    }
    /**
     * Process browse output using the parser
     */
    processBrowseOutput(output) {
        const results = parseBrowseOutput(output);
        for (const { action, service } of results) {
            switch (action) {
                case DNS_SD_ACTIONS.ADD:
                    this._discoveredServices.set(service.name, service);
                    this.emit('serviceAdded', service);
                    log.info(`Discovered service: ${service.name}`);
                    break;
                case DNS_SD_ACTIONS.REMOVE:
                    this._discoveredServices.delete(service.name);
                    this.emit('serviceRemoved', service.name);
                    log.info(`Service removed: ${service.name}`);
                    break;
                default:
                    log.debug(`Unknown action: ${action}`);
                    break;
            }
        }
    }
    /**
     * Initialize a browsing process
     */
    async initializeBrowsing(serviceType, domain) {
        this._isDiscovering = true;
        this._discoveredServices.clear();
        const browseProcess = createDnsSdBrowseProcess(serviceType, domain);
        this._browseProcess = browseProcess;
        try {
            await executeDnsSdCommand([DNS_SD_COMMANDS.BROWSE, serviceType, domain], BONJOUR_TIMEOUTS.BROWSE_STARTUP, (output) => {
                this.processBrowseOutput(output);
                return output.includes(DNS_SD_PATTERNS.STARTING);
            }, 'DNS-SD browse startup timeout');
            this.setupBrowseEventHandlers(browseProcess);
        }
        catch (error) {
            this._isDiscovering = false;
            throw error;
        }
    }
    /**
     * Setup event handlers for an ongoing browse process
     */
    setupBrowseEventHandlers(process) {
        process.stdout?.on('data', (data) => {
            const output = data.toString();
            log.debug(`dns-sd browse output: ${output}`);
            this.processBrowseOutput(output);
        });
        process.stderr?.on('data', (data) => {
            const error = data.toString();
            log.error(`dns-sd browse error: ${error}`);
        });
        process.on('exit', (code) => {
            if (code !== null && code !== 0) {
                log.error(`dns-sd browse process exited with error code: ${code}`);
            }
        });
        process.on('close', (code) => {
            log.debug(`dns-sd browse process closed with code: ${code}`);
            this.cleanup();
        });
    }
    /**
     * Resolve all discovered services
     */
    async resolveAllServices() {
        const services = this.getDiscoveredServices();
        log.info(`Found ${services.length} services to resolve`);
        const devices = [];
        for (const service of services) {
            try {
                log.info(`Attempting to resolve service: ${service.name}`);
                const resolvedService = await this.resolveService(service.name);
                const device = await convertToAppleTVDeviceWithIP(resolvedService);
                if (device) {
                    devices.push(device);
                }
            }
            catch (error) {
                log.warn(`Failed to resolve service ${service.name}: ${error}`);
            }
        }
        return devices;
    }
    /**
     * Cleanup resources
     */
    cleanup() {
        log.debug('Cleaning up BonjourDiscovery resources');
        this._browseProcess = undefined;
        this._isDiscovering = false;
        this._discoveredServices.clear();
    }
}
