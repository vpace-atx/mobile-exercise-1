import { logger } from '@appium/support';
import { EventEmitter } from 'events';
import { createServer } from 'net';
const log = logger.getLogger('PacketStreamServer');
/**
 * Server that exposes packet streaming from a tunnel over TCP
 * This allows cross-process access to tunnel packet streams
 */
export class PacketStreamServer extends EventEmitter {
    port;
    server = null;
    clients = new Set();
    packetConsumer = null;
    constructor(port) {
        super();
        this.port = port;
    }
    /**
     * Start the packet stream server
     * @throws {Error} If server is already started
     */
    async start() {
        if (this.server) {
            throw new Error('Server already started');
        }
        this.server = createServer((client) => {
            this.handleClientConnection(client);
        });
        this.packetConsumer = this.createPacketConsumer();
        return new Promise((resolve, reject) => {
            this.server.listen(this.port, () => {
                log.info(`Packet stream server listening on port ${this.port}`);
                resolve();
            });
            this.server.on('error', reject);
        });
    }
    async stop() {
        for (const client of this.clients) {
            client.destroy();
        }
        this.clients.clear();
        if (this.server) {
            return new Promise((resolve) => {
                this.server?.close(() => {
                    this.server = null;
                    resolve();
                });
            });
        }
    }
    getPacketConsumer() {
        return this.packetConsumer;
    }
    /**
     * Handle new client connection
     */
    handleClientConnection(client) {
        log.info(`Client connected from ${client.remoteAddress}`);
        this.clients.add(client);
        client.on('close', () => {
            log.info(`Client disconnected from ${client.remoteAddress}`);
            this.clients.delete(client);
        });
        client.on('error', (err) => {
            log.error(`Client error: ${err}`);
            this.clients.delete(client);
        });
    }
    /**
     * Create packet consumer that broadcasts packets to all connected clients
     */
    createPacketConsumer() {
        return {
            onPacket: (packet) => {
                this.broadcastPacket(packet);
            },
        };
    }
    /**
     * Broadcast packet to all connected clients
     */
    broadcastPacket(packet) {
        try {
            const serialized = JSON.stringify(packet);
            const message = this.createMessage(serialized);
            for (const client of this.clients) {
                if (!client.destroyed) {
                    client.write(message, (err) => {
                        if (err) {
                            log.error(`Failed to write to client: ${err}`);
                            this.clients.delete(client);
                        }
                    });
                }
            }
        }
        catch (err) {
            log.error(`Failed to broadcast packet: ${err}`);
        }
    }
    /**
     * Create a message buffer with length prefix
     */
    createMessage(data) {
        const lengthPrefix = data.length.toString().padStart(10, '0');
        return Buffer.concat([Buffer.from(lengthPrefix), Buffer.from(data)]);
    }
}
