import { type TunnelConnection } from 'appium-ios-tuntap';
import type { TLSSocket } from 'tls';
import { RemoteXpcConnection } from '../remote-xpc/remote-xpc-connection.js';
/**
 * A wrapper around the tunnel connection that
 * maintains a registry of active tunnels that can be reused.
 */
declare class TunnelManagerService {
    private tunnelRegistry;
    /**
     * Checks if a tunnel is already open for the given address
     *
     * @param address - The tunnel address to check
     * @returns True if a tunnel is open for the address, false otherwise
     */
    isTunnelOpen(address: string): boolean;
    /**
     * Gets all active tunnels
     *
     * @returns Array of active tunnel addresses
     */
    getActiveTunnels(): string[];
    /**
     * Creates a RemoteXPC connection for the specified device.
     *
     * @param address - The address of the tunnel
     * @param rsdPort - The RSD port of the tunnel
     * @returns A promise that resolves to the RemoteXPC connection
     */
    createRemoteXPCConnection(address: string, rsdPort: number): Promise<RemoteXpcConnection>;
    /**
     * Establishes a tunnel connection if not already connected.
     * If a tunnel is already open for the same address, it will be reused.
     *
     * @param secureServiceSocket - The secure service socket used to create the tunnel.
     * @returns A promise that resolves to the tunnel connection instance.
     */
    getTunnel(secureServiceSocket: TLSSocket): Promise<TunnelConnection>;
    /**
     * Gets an existing tunnel by address if available
     *
     * @param address - The tunnel address
     * @returns The tunnel if found and active, null otherwise
     */
    getTunnelByAddress(address: string): TunnelConnection | null;
    /**
     * Closes a specific tunnel connection by address.
     *
     * @param address - The address of the tunnel to close
     * @returns A promise that resolves when the tunnel is closed.
     */
    closeTunnelByAddress(address: string): Promise<void>;
    /**
     * Closes all tunnel connections and resets the registry.
     *
     * @returns A promise that resolves when all tunnels are closed.
     */
    closeAllTunnels(): Promise<void>;
    /**
     * Closes the tunnel connection for backward compatibility.
     * This method is kept for backward compatibility with existing code.
     *
     * @returns A promise that resolves when all tunnels are closed.
     */
    closeTunnel(): Promise<void>;
}
export declare const TunnelManager: TunnelManagerService;
export { PacketStreamClient } from './packet-stream-client.js';
export { PacketStreamServer } from './packet-stream-server.js';
//# sourceMappingURL=index.d.ts.map