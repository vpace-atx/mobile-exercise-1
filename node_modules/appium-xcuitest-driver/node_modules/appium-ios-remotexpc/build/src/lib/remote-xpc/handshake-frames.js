class Struct {
    types;
    constructor(fmt) {
        if (!fmt.startsWith('>')) {
            throw new Error('Only big-endian formats supported');
        }
        this.types = [];
        for (const ch of fmt.slice(1)) {
            if ('0123456789'.includes(ch)) {
                continue;
            }
            this.types.push(ch);
        }
    }
    byteLength() {
        let total = 0;
        for (const t of this.types) {
            switch (t) {
                case 'H':
                    total += 2;
                    break;
                case 'B':
                    total += 1;
                    break;
                case 'L':
                    total += 4;
                    break;
                default:
                    throw new TypeError('Unsupported type: ' + t);
            }
        }
        return total;
    }
    pack(...values) {
        if (values.length !== this.types.length) {
            throw new TypeError('Incorrect number of values to pack');
        }
        const buf = Buffer.alloc(this.byteLength());
        let offset = 0;
        for (const [i, t] of this.types.entries()) {
            const v = values[i];
            switch (t) {
                case 'H':
                    buf.writeUInt16BE(v, offset);
                    offset += 2;
                    break;
                case 'B':
                    buf.writeUInt8(v, offset);
                    offset += 1;
                    break;
                case 'L':
                    buf.writeUInt32BE(v, offset);
                    offset += 4;
                    break;
                default:
                    throw new TypeError('Unsupported type: ' + t);
            }
        }
        return buf;
    }
}
// Struct constants
const STRUCT_HBBBL = new Struct('>HBBBL');
const STRUCT_HL = new Struct('>HL');
const STRUCT_LB = new Struct('>LB');
const STRUCT_L = new Struct('>L');
const STRUCT_B = new Struct('>B');
const STREAM_ASSOC_HAS_STREAM = 'has-stream';
const STREAM_ASSOC_NO_STREAM = 'no-stream';
const STREAM_ASSOC_EITHER = 'either';
// Error classes
class HyperframeError extends Error {
}
class InvalidDataError extends HyperframeError {
}
// Flag handling
class Flag {
    name;
    bit;
    constructor(name, bit) {
        this.name = name;
        this.bit = bit;
    }
}
class Flags {
    definedFlags;
    flags;
    constructor(definedFlags) {
        this.definedFlags = definedFlags;
        this.flags = new Set();
    }
    add(flag) {
        this.flags.add(flag);
    }
    has(flag) {
        return this.flags.has(flag);
    }
    toString() {
        return Array.from(this.flags).join(', ');
    }
}
// Utility function
function rawDataRepr(data) {
    if (!data || data.length === 0) {
        return 'None';
    }
    let r = data.toString('hex');
    if (r.length > 20) {
        r = r.slice(0, 20) + '\u2026';
    }
    return '<hex:' + r + '>';
}
// Base frame class
export class Frame {
    definedFlags = [];
    type = null;
    streamAssociation = null;
    streamId;
    flags;
    bodyLen;
    constructor(streamId, flags = []) {
        this.streamId = streamId;
        this.flags = new Flags(this.definedFlags);
        this.bodyLen = 0;
        for (const flag of flags) {
            this.flags.add(flag);
        }
        if (!this.streamId && this.streamAssociation === STREAM_ASSOC_HAS_STREAM) {
            throw new InvalidDataError(`Stream ID must be non-zero for ${this.constructor.name}`);
        }
        if (this.streamId && this.streamAssociation === STREAM_ASSOC_NO_STREAM) {
            throw new InvalidDataError(`Stream ID must be zero for ${this.constructor.name} with streamId=${this.streamId}`);
        }
    }
    toString() {
        return `${this.constructor.name}(streamId=${this.streamId}, flags=${this.flags.toString()}): ${this.bodyRepr()}`;
    }
    serialize() {
        const body = this.serializeBody();
        this.bodyLen = body.length;
        let flagsVal = 0;
        for (const f of this.definedFlags) {
            if (this.flags.has(f.name)) {
                flagsVal |= f.bit;
            }
        }
        const header = STRUCT_HBBBL.pack((this.bodyLen >> 8) & 0xffff, this.bodyLen & 0xff, this.type, flagsVal, this.streamId & 0x7fffffff);
        return Buffer.concat([header, body]);
    }
    serializeBody() {
        throw new Error('Not implemented');
    }
    bodyRepr() {
        return rawDataRepr(this.serializeBody());
    }
}
// Specific frame implementations
export class SettingsFrame extends Frame {
    static MAX_CONCURRENT_STREAMS = 0x03;
    static INITIAL_WINDOW_SIZE = 0x04;
    settings;
    constructor(streamId = 0, settings = null, flags = []) {
        super(streamId, flags);
        this.definedFlags = [new Flag('ACK', 0x01)];
        this.type = 0x04;
        this.streamAssociation = STREAM_ASSOC_NO_STREAM;
        if (settings && flags.includes('ACK')) {
            throw new InvalidDataError('Settings must be empty if ACK flag is set.');
        }
        this.settings = settings || {};
    }
    bodyRepr() {
        return `settings=${JSON.stringify(this.settings)}`;
    }
    serializeBody() {
        if (this.flags.has('ACK')) {
            return Buffer.alloc(0);
        }
        const buffers = [];
        for (const setting of Object.keys(this.settings)) {
            const buf = STRUCT_HL.pack(Number(setting) & 0xff, this.settings[Number(setting)]);
            buffers.push(buf);
        }
        return Buffer.concat(buffers);
    }
}
export class DataFrame extends Frame {
    data;
    padLength;
    constructor(streamId, data = Buffer.from(''), flags = []) {
        super(streamId, flags);
        this.definedFlags = [
            new Flag('END_STREAM', 0x01),
            new Flag('PADDED', 0x08),
        ];
        this.type = 0x0;
        this.streamAssociation = STREAM_ASSOC_HAS_STREAM;
        this.padLength = 0;
        this.data = Buffer.isBuffer(data) ? data : Buffer.from(data);
    }
    serializePaddingData() {
        if (this.flags.has('PADDED')) {
            return STRUCT_B.pack(this.padLength);
        }
        return Buffer.alloc(0);
    }
    serializeBody() {
        const paddingData = this.serializePaddingData();
        const padding = Buffer.alloc(this.padLength, 0);
        // Ensure data is a Buffer
        if (!Buffer.isBuffer(this.data)) {
            this.data = Buffer.from(this.data);
        }
        const payload = Buffer.concat([paddingData, this.data, padding]);
        this.bodyLen = payload.length;
        return payload;
    }
}
export class HeadersFrame extends Frame {
    data;
    padLength;
    dependsOn;
    streamWeight;
    exclusive;
    static ALL_FLAGS = {
        END_STREAM: 0x01,
        END_HEADERS: 0x04,
        PADDED: 0x08,
        PRIORITY: 0x20,
    };
    constructor(streamId, data = Buffer.from(''), flags = []) {
        super(streamId, flags);
        // Map given flags to Flag objects using ALL_FLAGS
        this.definedFlags = flags.map((flag) => new Flag(flag, HeadersFrame.ALL_FLAGS[flag]));
        this.type = 0x01;
        this.streamAssociation = STREAM_ASSOC_HAS_STREAM;
        this.padLength = 0;
        this.dependsOn = 0;
        this.streamWeight = 0;
        this.exclusive = false;
        this.data = Buffer.isBuffer(data) ? data : Buffer.from(data);
    }
    serializePaddingData() {
        if (this.flags.has('PADDED')) {
            return STRUCT_B.pack(this.padLength);
        }
        return Buffer.alloc(0);
    }
    serializePriorityData() {
        return STRUCT_LB.pack(this.dependsOn + (this.exclusive ? 0x80000000 : 0), this.streamWeight);
    }
    bodyRepr() {
        return `exclusive=${this.exclusive}, dependsOn=${this.dependsOn}, streamWeight=${this.streamWeight}, data=${rawDataRepr(this.data)}`;
    }
    serializeBody() {
        const paddingData = this.serializePaddingData();
        const padding = Buffer.alloc(this.padLength, 0);
        let priorityData;
        if (this.flags.has('PRIORITY')) {
            priorityData = this.serializePriorityData();
        }
        else {
            priorityData = Buffer.alloc(0);
        }
        return Buffer.concat([paddingData, priorityData, this.data, padding]);
    }
}
export class WindowUpdateFrame extends Frame {
    windowIncrement;
    constructor(streamId, windowIncrement = 0, flags = []) {
        super(streamId, flags);
        this.definedFlags = [];
        this.type = 0x08;
        this.streamAssociation = STREAM_ASSOC_EITHER;
        this.windowIncrement = windowIncrement;
    }
    bodyRepr() {
        return `windowIncrement=${this.windowIncrement}`;
    }
    serializeBody() {
        return STRUCT_L.pack(this.windowIncrement & 0x7fffffff);
    }
}
// Exported constants and types
export { InvalidDataError, STRUCT_HL };
