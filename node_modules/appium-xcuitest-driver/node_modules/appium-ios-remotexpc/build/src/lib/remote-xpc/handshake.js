import { Socket } from 'net';
import {} from '../types.js';
import { Http2Constants, XpcConstants } from './constants.js';
import { DataFrame, HeadersFrame, SettingsFrame, WindowUpdateFrame, } from './handshake-frames.js';
import { encodeMessage } from './xpc-protocol.js';
class Handshake {
    _socket;
    _nextMessageId;
    constructor(socket) {
        this._socket = socket;
        this._nextMessageId = {
            [Http2Constants.ROOT_CHANNEL]: 0,
            [Http2Constants.REPLY_CHANNEL]: 0,
        };
    }
    async sendFrame(frame) {
        return new Promise((resolve, reject) => {
            if (!this._socket.writable) {
                return reject(new Error('Socket is not writable'));
            }
            this._socket.write(frame, (error) => error ? reject(error) : resolve());
        });
    }
    async sendRequest(data) {
        const flags = XpcConstants.XPC_FLAGS_ALWAYS_SET;
        const requestMessage = {
            flags,
            id: BigInt(this._nextMessageId[Http2Constants.ROOT_CHANNEL]),
            body: data,
        };
        const encodedMessage = encodeMessage(requestMessage);
        const dataFrame = new DataFrame(Http2Constants.ROOT_CHANNEL, encodedMessage, []);
        await this.sendFrame(dataFrame.serialize());
    }
    async perform() {
        try {
            // Step 1: Send HTTP/2 magic sequence with proper error handling
            await new Promise((resolve, reject) => {
                if (!this._socket.writable) {
                    return reject(new Error('Socket is not writable for HTTP/2 magic sequence'));
                }
                this._socket.write(Http2Constants.HTTP2_MAGIC, (err) => err ? reject(err) : resolve());
            });
            // Step 2: Send SETTINGS frame on stream 0.
            const settings = {
                [SettingsFrame.MAX_CONCURRENT_STREAMS]: 100,
                [SettingsFrame.INITIAL_WINDOW_SIZE]: 1048576,
            };
            const settingsFrame = new SettingsFrame(0, settings, []);
            await this.sendFrame(settingsFrame.serialize());
            // Step 3: Send WINDOW_UPDATE frame on stream 0.
            const windowUpdateFrame = new WindowUpdateFrame(0, 983041);
            await this.sendFrame(windowUpdateFrame.serialize());
            // Step 4: Send a HEADERS frame on stream 1.
            const headersFrameRoot = new HeadersFrame(Http2Constants.ROOT_CHANNEL, Buffer.from(''), ['END_HEADERS']);
            await this.sendFrame(headersFrameRoot.serialize());
            // Step 5: Send first DataFrame on stream 1 (empty payload).
            await this.sendRequest({});
            // Step 6: Send second DataFrame on stream 1 with specific flags.
            const dataMessage = {
                flags: 0x0201,
                id: 0,
                body: null,
            };
            const encodedDataMessage = encodeMessage(dataMessage);
            const dataFrame = new DataFrame(Http2Constants.ROOT_CHANNEL, encodedDataMessage, []);
            await this.sendFrame(dataFrame.serialize());
            this._nextMessageId[Http2Constants.ROOT_CHANNEL]++;
            // Step 7: Send a HEADERS frame on stream 3.
            const headersFrameReply = new HeadersFrame(Http2Constants.REPLY_CHANNEL, Buffer.from(''), ['END_HEADERS']);
            await this.sendFrame(headersFrameReply.serialize());
            // Step 8: Open REPLY_CHANNEL with INIT_HANDSHAKE flags.
            const replyMessage = {
                flags: XpcConstants.XPC_FLAGS_ALWAYS_SET |
                    XpcConstants.XPC_FLAGS_INIT_HANDSHAKE,
                id: 0,
                body: null,
            };
            const encodedReplyMessage = encodeMessage(replyMessage);
            const replyDataFrame = new DataFrame(Http2Constants.REPLY_CHANNEL, encodedReplyMessage, []);
            await this.sendFrame(replyDataFrame.serialize());
            this._nextMessageId[Http2Constants.REPLY_CHANNEL]++;
            // Step 9: Send SETTINGS ACK frame.
            const ackFrame = new SettingsFrame(0, null, ['ACK']);
            await this.sendFrame(ackFrame.serialize());
        }
        catch (error) {
            // Provide detailed error information
            throw new Error(error instanceof Error
                ? `Handshake failed at step: ${error.message}`
                : 'Unknown handshake error');
        }
    }
}
export default Handshake;
