/**
 * Computes a cryptographic hash of the provided input buffers.
 *
 * @param inputs - Variable number of Buffer objects to hash
 * @returns The computed hash as a Buffer
 * @throws {Error} If no inputs provided
 */
export declare function hash(...inputs: Buffer[]): Buffer;
/**
 * Calculates the SRP multiplier parameter k = H(N, g).
 *
 * @param N - The large safe prime modulus
 * @param g - The generator
 * @param keyLength - The key length in bytes
 * @returns The calculated k value as a bigint
 * @throws {Error} If parameters are invalid
 */
export declare function calculateK(N: bigint, g: bigint, keyLength: number): bigint;
/**
 * Calculates the private key x = H(salt, H(username:password)).
 *
 * @param salt - The salt buffer
 * @param username - The username string
 * @param password - The password string
 * @returns The calculated x value as a bigint
 * @throws {Error} If parameters are invalid
 */
export declare function calculateX(salt: Buffer, username: string, password: string): bigint;
/**
 * Calculates the random scrambling parameter u = H(A, B).
 *
 * @param A - The client's public key
 * @param B - The server's public key
 * @param keyLength - The key length in bytes
 * @returns The calculated u value as a bigint
 * @throws {Error} If parameters are invalid
 */
export declare function calculateU(A: bigint, B: bigint, keyLength: number): bigint;
/**
 * Calculates the client evidence M1 = H(H(N) xor H(g), H(username), salt, A, B, K).
 *
 * @param N - The large safe prime modulus
 * @param g - The generator
 * @param username - The username string
 * @param salt - The salt buffer
 * @param A - The client's public key
 * @param B - The server's public key
 * @param K - The session key
 * @returns The calculated M1 evidence as a Buffer
 * @throws {Error} If parameters are invalid
 */
export declare function calculateM1(N: bigint, g: bigint, username: string, salt: Buffer, A: bigint, B: bigint, K: Buffer): Buffer;
//# sourceMappingURL=crypto-utils.d.ts.map