/**
 * Converts a non-negative bigint to a fixed-length Buffer in big-endian format.
 *
 * @param value - The bigint value to convert (must be non-negative).
 * @param length - The target buffer length in bytes.
 * @returns A Buffer representing the bigint, padded to the specified length.
 *
 * @throws {RangeError} If the value is negative or doesn't fit in the specified length.
 */
export declare function bigIntToBuffer(value: bigint, length: number): Buffer;
/**
 * Converts a Buffer into a bigint by interpreting it as a big-endian hexadecimal number.
 *
 * @param buffer - The input Buffer.
 * @returns A bigint representing the numeric value of the buffer.
 */
export declare function bufferToBigInt(buffer: Buffer): bigint;
/**
 * Converts a non-negative bigint into a minimal-length Buffer in big-endian format.
 * No unnecessary leading zero bytes will be included.
 *
 * @param value - The bigint value to convert (must be non-negative).
 * @returns A Buffer representing the bigint with minimal byte length.
 *
 * @throws {RangeError} If the value is negative.
 */
export declare function bigIntToMinimalBuffer(value: bigint): Buffer;
/**
 * Computes modular exponentiation: (base ^ exponent) % modulus.
 * Efficiently handles large numbers using the binary exponentiation method.
 *
 * @param base - The base number.
 * @param exponent - The exponent (must be non-negative).
 * @param modulus - The modulus (must be non-zero).
 * @returns The result of (base ** exponent) modulo modulus.
 *
 * @throws {RangeError} If the exponent is negative or the modulus is zero.
 */
export declare function modPow(base: bigint, exponent: bigint, modulus: bigint): bigint;
//# sourceMappingURL=buffer-utils.d.ts.map