"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.backupKeychains = backupKeychains;
exports.restoreKeychains = restoreKeychains;
exports.clearKeychains = clearKeychains;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const support_1 = require("@appium/support");
const teen_process_1 = require("teen_process");
/**
 * Create the backup of keychains folder.
 * The previously created backup will be automatically
 * deleted if this method was called twice in a row without
 * `restoreKeychains` being invoked.
 *
 * @this {CoreSimulatorWithKeychain}
 * @returns {Promise<boolean>} True if the backup operation was successfull.
 */
async function backupKeychains() {
    const resetBackupPath = async (/** @type {string | null | undefined} */ newPath) => {
        if (lodash_1.default.isString(this._keychainsBackupPath) && await support_1.fs.exists(this._keychainsBackupPath)) {
            await support_1.fs.unlink(this._keychainsBackupPath);
        }
        this._keychainsBackupPath = newPath;
    };
    if (!await support_1.fs.exists(this.keychainPath) || lodash_1.default.isEmpty(await support_1.fs.readdir(this.keychainPath))) {
        this.log.info(`There is nothing to backup from '${this.keychainPath}'`);
        await resetBackupPath(null);
        return false;
    }
    const dstPath = await support_1.tempDir.path({
        prefix: `keychains_backup_${Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1)}`,
        suffix: '.zip',
    });
    const zipArgs = ['-r', dstPath, `${path_1.default.basename(this.keychainPath)}${path_1.default.sep}`];
    this.log.debug(`Creating keychains backup with '${support_1.util.quote(['zip', ...zipArgs])}' command`);
    try {
        await (0, teen_process_1.exec)('zip', zipArgs, { cwd: path_1.default.dirname(this.keychainPath) });
    }
    catch (err) {
        throw new Error(`Cannot create keychains backup from '${this.keychainPath}'. ` +
            `Original error: ${err.stderr || err.stdout || err.message}`);
    }
    await resetBackupPath(dstPath);
    return true;
}
/**
 * Restore the previsouly created keychains backup.
 *
 * @this {CoreSimulatorWithKeychain}
 * @param {string[]} excludePatterns - The list
 * of file name patterns to be excluded from restore. The format
 * of each item should be the same as '-x' option format for
 * 'unzip' utility. This can also be a comma-separated string,
 * which is going be transformed into a list automatically,
 * for example: '*.db*,blabla.sqlite'
 * @returns {Promise<boolean>} If the restore opration was successful.
 * @throws {Error} If there is no keychains backup available for restore.
 */
async function restoreKeychains(excludePatterns = []) {
    if (!lodash_1.default.isString(this._keychainsBackupPath) || !await support_1.fs.exists(this._keychainsBackupPath)) {
        throw new Error(`The keychains backup archive does not exist. ` +
            `Are you sure it was created before?`);
    }
    if (lodash_1.default.isString(excludePatterns)) {
        excludePatterns = excludePatterns.split(',').map((x) => x.trim());
    }
    const isServerRunning = await this.isRunning();
    let plistPath;
    if (isServerRunning) {
        plistPath = path_1.default.resolve(await this.getLaunchDaemonsRoot(), 'com.apple.securityd.plist');
        if (!await support_1.fs.exists(plistPath)) {
            throw new Error(`Cannot clear keychains because '${plistPath}' does not exist`);
        }
        await this.simctl.spawnProcess(['launchctl', 'unload', plistPath]);
    }
    try {
        await support_1.fs.rimraf(this.keychainPath);
        await (0, support_1.mkdirp)(this.keychainPath);
        const unzipArgs = [
            '-o', this._keychainsBackupPath,
            ...(lodash_1.default.flatMap(excludePatterns.map((x) => ['-x', x]))),
            '-d', path_1.default.dirname(this.keychainPath),
        ];
        this.log.debug(`Restoring keychains with '${support_1.util.quote(['unzip', ...unzipArgs])}' command`);
        try {
            await (0, teen_process_1.exec)('unzip', unzipArgs);
        }
        catch (err) {
            throw new Error(`Cannot restore keychains from '${this._keychainsBackupPath}'. ` +
                `Original error: ${err.stderr || err.stdout || err.message}`);
        }
        await support_1.fs.unlink(this._keychainsBackupPath);
        this._keychainsBackupPath = null;
    }
    finally {
        if (isServerRunning && plistPath) {
            await this.simctl.spawnProcess(['launchctl', 'load', plistPath]);
        }
    }
    return true;
}
/**
 * Clears Keychains for the particular simulator in runtime (there is no need to stop it).
 *
 * @this {CoreSimulatorWithKeychain}
 * @returns {Promise<void>}
 * @throws {Error} If keychain cleanup has failed.
 */
async function clearKeychains() {
    const plistPath = path_1.default.resolve(await this.getLaunchDaemonsRoot(), 'com.apple.securityd.plist');
    if (!await support_1.fs.exists(plistPath)) {
        throw new Error(`Cannot clear keychains because '${plistPath}' does not exist`);
    }
    await this.simctl.spawnProcess(['launchctl', 'unload', plistPath]);
    try {
        if (await support_1.fs.exists(this.keychainPath)) {
            await support_1.fs.rimraf(this.keychainPath);
            await (0, support_1.mkdirp)(this.keychainPath);
        }
    }
    finally {
        await this.simctl.spawnProcess(['launchctl', 'load', plistPath]);
    }
}
/**
 * @typedef {import('../types').CoreSimulator & import('../types').InteractsWithKeychain} CoreSimulatorWithKeychain
 */
//# sourceMappingURL=keychain.js.map